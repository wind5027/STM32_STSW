; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210b-eval\stm3210b_eval_spi_sd.o --asm_dir=.\STM3210B-EVAL\ --list_dir=.\STM3210B-EVAL\ --depend=.\stm3210b-eval\stm3210b_eval_spi_sd.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210B_EVAL -ID:\Complier\Keil_v5\ARM\RV31\INC -ID:\Complier\Keil_v5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -ID:\Complier\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210B_EVAL --omf_browse=.\stm3210b-eval\stm3210b_eval_spi_sd.crf ..\..\..\Utilities\STM32_EVAL\STM3210B_EVAL\stm3210b_eval_spi_sd.c]
                          THUMB

                          AREA ||i.SD_DeInit||, CODE, READONLY, ALIGN=1

                  SD_DeInit PROC
;;;123      */
;;;124    void SD_DeInit(void)
000000  f7ffbffe          B.W      SD_LowLevel_DeInit
;;;125    {
;;;126      SD_LowLevel_DeInit();
;;;127    }
;;;128    
                          ENDP


                          AREA ||i.SD_Detect||, CODE, READONLY, ALIGN=2

                  SD_Detect PROC
;;;162     */
;;;163    uint8_t SD_Detect(void)
000000  b508              PUSH     {r3,lr}
;;;164    {
;;;165      __IO uint8_t status = SD_PRESENT;
000002  2001              MOVS     r0,#1
000004  f88d0000          STRB     r0,[sp,#0]
;;;166    
;;;167      /*!< Check GPIO to detect SD */
;;;168      if (GPIO_ReadInputData(SD_DETECT_GPIO_PORT) & SD_DETECT_PIN)
000008  4805              LDR      r0,|L2.32|
00000a  f7fffffe          BL       GPIO_ReadInputData
00000e  0600              LSLS     r0,r0,#24
000010  d502              BPL      |L2.24|
;;;169      {
;;;170        status = SD_NOT_PRESENT;
000012  2000              MOVS     r0,#0
000014  f88d0000          STRB     r0,[sp,#0]
                  |L2.24|
;;;171      }
;;;172      return status;
000018  f89d0000          LDRB     r0,[sp,#0]
;;;173    }
00001c  bd08              POP      {r3,pc}
;;;174    
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      0x40011800

                          AREA ||i.SD_GetCIDRegister||, CODE, READONLY, ALIGN=2

                  SD_GetCIDRegister PROC
;;;564      */
;;;565    SD_Error SD_GetCIDRegister(SD_CID* SD_cid)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;566    {
;;;567      uint32_t i = 0;
;;;568      SD_Error rvalue = SD_RESPONSE_FAILURE;
;;;569      uint8_t CID_Tab[16];
;;;570      
;;;571      /*!< SD chip select low */
;;;572      SD_CS_LOW();
000004  f8df8100          LDR      r8,|L3.264|
000008  4604              MOV      r4,r0                 ;566
00000a  f44f5780          MOV      r7,#0x1000
00000e  2500              MOVS     r5,#0                 ;567
000010  26ff              MOVS     r6,#0xff              ;568
000012  4639              MOV      r1,r7
000014  4640              MOV      r0,r8
000016  f7fffffe          BL       GPIO_ResetBits
;;;573      
;;;574      /*!< Send CMD10 (CID register) */
;;;575      SD_SendCmd(SD_CMD_SEND_CID, 0, 0xFF);
00001a  22ff              MOVS     r2,#0xff
00001c  2100              MOVS     r1,#0
00001e  200a              MOVS     r0,#0xa
000020  f7fffffe          BL       SD_SendCmd
;;;576      
;;;577      /*!< Wait for response in the R1 format (0x00 is no errors) */
;;;578      if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       SD_GetResponse
00002a  b990              CBNZ     r0,|L3.82|
;;;579      {
;;;580        if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
00002c  20fe              MOVS     r0,#0xfe
00002e  f7fffffe          BL       SD_GetResponse
000032  b938              CBNZ     r0,|L3.68|
000034  ea4f060d          MOV.W    r6,sp                 ;569
                  |L3.56|
;;;581        {
;;;582          /*!< Store CID register value on CID_Tab */
;;;583          for (i = 0; i < 16; i++)
;;;584          {
;;;585            CID_Tab[i] = SD_ReadByte();
000038  f7fffffe          BL       SD_ReadByte
00003c  5570              STRB     r0,[r6,r5]
00003e  1c6d              ADDS     r5,r5,#1
000040  2d10              CMP      r5,#0x10              ;583
000042  d3f9              BCC      |L3.56|
                  |L3.68|
;;;586          }
;;;587        }
;;;588        /*!< Get CRC bytes (not really needed by us, but required by SD) */
;;;589        SD_WriteByte(SD_DUMMY_BYTE);
000044  20ff              MOVS     r0,#0xff
000046  f7fffffe          BL       SD_WriteByte
;;;590        SD_WriteByte(SD_DUMMY_BYTE);
00004a  20ff              MOVS     r0,#0xff
00004c  f7fffffe          BL       SD_WriteByte
;;;591        /*!< Set response value to success */
;;;592        rvalue = SD_RESPONSE_NO_ERROR;
000050  2600              MOVS     r6,#0
                  |L3.82|
;;;593      }
;;;594      /*!< SD chip select high */
;;;595      SD_CS_HIGH();
000052  4639              MOV      r1,r7
000054  4640              MOV      r0,r8
000056  f7fffffe          BL       GPIO_SetBits
;;;596      /*!< Send dummy byte: 8 Clock pulses of delay */
;;;597      SD_WriteByte(SD_DUMMY_BYTE);
00005a  20ff              MOVS     r0,#0xff
00005c  f7fffffe          BL       SD_WriteByte
;;;598    
;;;599      /*!< Byte 0 */
;;;600      SD_cid->ManufacturerID = CID_Tab[0];
000060  f89d0000          LDRB     r0,[sp,#0]
000064  7020              STRB     r0,[r4,#0]
;;;601    
;;;602      /*!< Byte 1 */
;;;603      SD_cid->OEM_AppliID = CID_Tab[1] << 8;
000066  f89d0001          LDRB     r0,[sp,#1]
00006a  0200              LSLS     r0,r0,#8
00006c  8060              STRH     r0,[r4,#2]
;;;604    
;;;605      /*!< Byte 2 */
;;;606      SD_cid->OEM_AppliID |= CID_Tab[2];
00006e  8860              LDRH     r0,[r4,#2]
000070  f89d1002          LDRB     r1,[sp,#2]
000074  4308              ORRS     r0,r0,r1
000076  8060              STRH     r0,[r4,#2]
;;;607    
;;;608      /*!< Byte 3 */
;;;609      SD_cid->ProdName1 = CID_Tab[3] << 24;
000078  f89d0003          LDRB     r0,[sp,#3]
00007c  0600              LSLS     r0,r0,#24
00007e  6060              STR      r0,[r4,#4]
;;;610    
;;;611      /*!< Byte 4 */
;;;612      SD_cid->ProdName1 |= CID_Tab[4] << 16;
000080  6860              LDR      r0,[r4,#4]
000082  f89d1004          LDRB     r1,[sp,#4]
000086  ea404001          ORR      r0,r0,r1,LSL #16
00008a  6060              STR      r0,[r4,#4]
;;;613    
;;;614      /*!< Byte 5 */
;;;615      SD_cid->ProdName1 |= CID_Tab[5] << 8;
00008c  6860              LDR      r0,[r4,#4]
00008e  f89d1005          LDRB     r1,[sp,#5]
000092  ea402001          ORR      r0,r0,r1,LSL #8
000096  6060              STR      r0,[r4,#4]
;;;616    
;;;617      /*!< Byte 6 */
;;;618      SD_cid->ProdName1 |= CID_Tab[6];
000098  6860              LDR      r0,[r4,#4]
00009a  f89d1006          LDRB     r1,[sp,#6]
00009e  4308              ORRS     r0,r0,r1
0000a0  6060              STR      r0,[r4,#4]
;;;619    
;;;620      /*!< Byte 7 */
;;;621      SD_cid->ProdName2 = CID_Tab[7];
0000a2  f89d0007          LDRB     r0,[sp,#7]
0000a6  7220              STRB     r0,[r4,#8]
;;;622    
;;;623      /*!< Byte 8 */
;;;624      SD_cid->ProdRev = CID_Tab[8];
0000a8  f89d0008          LDRB     r0,[sp,#8]
0000ac  7260              STRB     r0,[r4,#9]
;;;625    
;;;626      /*!< Byte 9 */
;;;627      SD_cid->ProdSN = CID_Tab[9] << 24;
0000ae  f89d0009          LDRB     r0,[sp,#9]
0000b2  0600              LSLS     r0,r0,#24
0000b4  60e0              STR      r0,[r4,#0xc]
;;;628    
;;;629      /*!< Byte 10 */
;;;630      SD_cid->ProdSN |= CID_Tab[10] << 16;
0000b6  68e0              LDR      r0,[r4,#0xc]
0000b8  f89d100a          LDRB     r1,[sp,#0xa]
0000bc  ea404001          ORR      r0,r0,r1,LSL #16
0000c0  60e0              STR      r0,[r4,#0xc]
;;;631    
;;;632      /*!< Byte 11 */
;;;633      SD_cid->ProdSN |= CID_Tab[11] << 8;
0000c2  68e0              LDR      r0,[r4,#0xc]
0000c4  f89d100b          LDRB     r1,[sp,#0xb]
0000c8  ea402001          ORR      r0,r0,r1,LSL #8
0000cc  60e0              STR      r0,[r4,#0xc]
;;;634    
;;;635      /*!< Byte 12 */
;;;636      SD_cid->ProdSN |= CID_Tab[12];
0000ce  68e0              LDR      r0,[r4,#0xc]
0000d0  f89d100c          LDRB     r1,[sp,#0xc]
0000d4  4308              ORRS     r0,r0,r1
0000d6  60e0              STR      r0,[r4,#0xc]
;;;637    
;;;638      /*!< Byte 13 */
;;;639      SD_cid->Reserved1 |= (CID_Tab[13] & 0xF0) >> 4;
0000d8  7c21              LDRB     r1,[r4,#0x10]
0000da  f89d000d          LDRB     r0,[sp,#0xd]
0000de  ea411110          ORR      r1,r1,r0,LSR #4
0000e2  7421              STRB     r1,[r4,#0x10]
;;;640      SD_cid->ManufactDate = (CID_Tab[13] & 0x0F) << 8;
0000e4  0700              LSLS     r0,r0,#28
0000e6  0d00              LSRS     r0,r0,#20
0000e8  8260              STRH     r0,[r4,#0x12]
;;;641    
;;;642      /*!< Byte 14 */
;;;643      SD_cid->ManufactDate |= CID_Tab[14];
0000ea  8a60              LDRH     r0,[r4,#0x12]
0000ec  f89d100e          LDRB     r1,[sp,#0xe]
0000f0  4308              ORRS     r0,r0,r1
0000f2  8260              STRH     r0,[r4,#0x12]
;;;644    
;;;645      /*!< Byte 15 */
;;;646      SD_cid->CID_CRC = (CID_Tab[15] & 0xFE) >> 1;
0000f4  f89d000f          LDRB     r0,[sp,#0xf]
0000f8  0840              LSRS     r0,r0,#1
0000fa  7520              STRB     r0,[r4,#0x14]
;;;647      SD_cid->Reserved2 = 1;
0000fc  2001              MOVS     r0,#1
0000fe  7560              STRB     r0,[r4,#0x15]
;;;648    
;;;649      /*!< Return the reponse */
;;;650      return rvalue;
;;;651    }
000100  b004              ADD      sp,sp,#0x10
000102  4630              MOV      r0,r6                 ;650
000104  e8bd81f0          POP      {r4-r8,pc}
;;;652    
                          ENDP

                  |L3.264|
                          DCD      0x40011000

                          AREA ||i.SD_GetCSDRegister||, CODE, READONLY, ALIGN=2

                  SD_GetCSDRegister PROC
;;;442      */
;;;443    SD_Error SD_GetCSDRegister(SD_CSD* SD_csd)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;444    {
;;;445      uint32_t i = 0;
;;;446      SD_Error rvalue = SD_RESPONSE_FAILURE;
;;;447      uint8_t CSD_Tab[16];
;;;448    
;;;449      /*!< SD chip select low */
;;;450      SD_CS_LOW();
000004  f8df81a4          LDR      r8,|L4.428|
000008  4604              MOV      r4,r0                 ;444
00000a  f44f5780          MOV      r7,#0x1000
00000e  2600              MOVS     r6,#0                 ;445
000010  25ff              MOVS     r5,#0xff              ;446
000012  4639              MOV      r1,r7
000014  4640              MOV      r0,r8
000016  f7fffffe          BL       GPIO_ResetBits
;;;451      /*!< Send CMD9 (CSD register) or CMD10(CSD register) */
;;;452      SD_SendCmd(SD_CMD_SEND_CSD, 0, 0xFF);
00001a  22ff              MOVS     r2,#0xff
00001c  2100              MOVS     r1,#0
00001e  2009              MOVS     r0,#9
000020  f7fffffe          BL       SD_SendCmd
;;;453      /*!< Wait for response in the R1 format (0x00 is no errors) */
;;;454      if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       SD_GetResponse
00002a  b990              CBNZ     r0,|L4.82|
;;;455      {
;;;456        if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
00002c  20fe              MOVS     r0,#0xfe
00002e  f7fffffe          BL       SD_GetResponse
000032  b938              CBNZ     r0,|L4.68|
000034  ea4f050d          MOV.W    r5,sp                 ;447
                  |L4.56|
;;;457        {
;;;458          for (i = 0; i < 16; i++)
;;;459          {
;;;460            /*!< Store CSD register value on CSD_Tab */
;;;461            CSD_Tab[i] = SD_ReadByte();
000038  f7fffffe          BL       SD_ReadByte
00003c  55a8              STRB     r0,[r5,r6]
00003e  1c76              ADDS     r6,r6,#1
000040  2e10              CMP      r6,#0x10              ;458
000042  d3f9              BCC      |L4.56|
                  |L4.68|
;;;462          }
;;;463        }
;;;464        /*!< Get CRC bytes (not really needed by us, but required by SD) */
;;;465        SD_WriteByte(SD_DUMMY_BYTE);
000044  20ff              MOVS     r0,#0xff
000046  f7fffffe          BL       SD_WriteByte
;;;466        SD_WriteByte(SD_DUMMY_BYTE);
00004a  20ff              MOVS     r0,#0xff
00004c  f7fffffe          BL       SD_WriteByte
;;;467        /*!< Set response value to success */
;;;468        rvalue = SD_RESPONSE_NO_ERROR;
000050  2500              MOVS     r5,#0
                  |L4.82|
;;;469      }
;;;470      /*!< SD chip select high */
;;;471      SD_CS_HIGH();
000052  4639              MOV      r1,r7
000054  4640              MOV      r0,r8
000056  f7fffffe          BL       GPIO_SetBits
;;;472      /*!< Send dummy byte: 8 Clock pulses of delay */
;;;473      SD_WriteByte(SD_DUMMY_BYTE);
00005a  20ff              MOVS     r0,#0xff
00005c  f7fffffe          BL       SD_WriteByte
;;;474    
;;;475      /*!< Byte 0 */
;;;476      SD_csd->CSDStruct = (CSD_Tab[0] & 0xC0) >> 6;
000060  f89d0000          LDRB     r0,[sp,#0]
000064  0981              LSRS     r1,r0,#6
000066  7021              STRB     r1,[r4,#0]
;;;477      SD_csd->SysSpecVersion = (CSD_Tab[0] & 0x3C) >> 2;
000068  f3c00183          UBFX     r1,r0,#2,#4
00006c  7061              STRB     r1,[r4,#1]
;;;478      SD_csd->Reserved1 = CSD_Tab[0] & 0x03;
00006e  f0000003          AND      r0,r0,#3
000072  70a0              STRB     r0,[r4,#2]
;;;479    
;;;480      /*!< Byte 1 */
;;;481      SD_csd->TAAC = CSD_Tab[1];
000074  f89d0001          LDRB     r0,[sp,#1]
000078  70e0              STRB     r0,[r4,#3]
;;;482    
;;;483      /*!< Byte 2 */
;;;484      SD_csd->NSAC = CSD_Tab[2];
00007a  f89d0002          LDRB     r0,[sp,#2]
00007e  7120              STRB     r0,[r4,#4]
;;;485    
;;;486      /*!< Byte 3 */
;;;487      SD_csd->MaxBusClkFrec = CSD_Tab[3];
000080  f89d0003          LDRB     r0,[sp,#3]
000084  7160              STRB     r0,[r4,#5]
;;;488    
;;;489      /*!< Byte 4 */
;;;490      SD_csd->CardComdClasses = CSD_Tab[4] << 4;
000086  f89d0004          LDRB     r0,[sp,#4]
00008a  0100              LSLS     r0,r0,#4
00008c  80e0              STRH     r0,[r4,#6]
;;;491    
;;;492      /*!< Byte 5 */
;;;493      SD_csd->CardComdClasses |= (CSD_Tab[5] & 0xF0) >> 4;
00008e  88e1              LDRH     r1,[r4,#6]
000090  f89d0005          LDRB     r0,[sp,#5]
000094  ea411110          ORR      r1,r1,r0,LSR #4
000098  80e1              STRH     r1,[r4,#6]
;;;494      SD_csd->RdBlockLen = CSD_Tab[5] & 0x0F;
00009a  f000000f          AND      r0,r0,#0xf
00009e  7220              STRB     r0,[r4,#8]
;;;495    
;;;496      /*!< Byte 6 */
;;;497      SD_csd->PartBlockRead = (CSD_Tab[6] & 0x80) >> 7;
0000a0  f89d0006          LDRB     r0,[sp,#6]
0000a4  09c1              LSRS     r1,r0,#7
0000a6  7261              STRB     r1,[r4,#9]
;;;498      SD_csd->WrBlockMisalign = (CSD_Tab[6] & 0x40) >> 6;
0000a8  f3c01180          UBFX     r1,r0,#6,#1
0000ac  72a1              STRB     r1,[r4,#0xa]
;;;499      SD_csd->RdBlockMisalign = (CSD_Tab[6] & 0x20) >> 5;
0000ae  f3c01140          UBFX     r1,r0,#5,#1
0000b2  72e1              STRB     r1,[r4,#0xb]
;;;500      SD_csd->DSRImpl = (CSD_Tab[6] & 0x10) >> 4;
0000b4  f3c01100          UBFX     r1,r0,#4,#1
0000b8  7321              STRB     r1,[r4,#0xc]
;;;501      SD_csd->Reserved2 = 0; /*!< Reserved */
0000ba  2100              MOVS     r1,#0
0000bc  7361              STRB     r1,[r4,#0xd]
;;;502    
;;;503      SD_csd->DeviceSize = (CSD_Tab[6] & 0x03) << 10;
0000be  0780              LSLS     r0,r0,#30
0000c0  0d00              LSRS     r0,r0,#20
0000c2  6120              STR      r0,[r4,#0x10]
;;;504    
;;;505      /*!< Byte 7 */
;;;506      SD_csd->DeviceSize |= (CSD_Tab[7]) << 2;
0000c4  6920              LDR      r0,[r4,#0x10]
0000c6  f89d2007          LDRB     r2,[sp,#7]
0000ca  ea400082          ORR      r0,r0,r2,LSL #2
0000ce  6120              STR      r0,[r4,#0x10]
;;;507    
;;;508      /*!< Byte 8 */
;;;509      SD_csd->DeviceSize |= (CSD_Tab[8] & 0xC0) >> 6;
0000d0  6922              LDR      r2,[r4,#0x10]
0000d2  f89d0008          LDRB     r0,[sp,#8]
0000d6  ea421290          ORR      r2,r2,r0,LSR #6
0000da  6122              STR      r2,[r4,#0x10]
;;;510    
;;;511      SD_csd->MaxRdCurrentVDDMin = (CSD_Tab[8] & 0x38) >> 3;
0000dc  f3c002c2          UBFX     r2,r0,#3,#3
0000e0  7522              STRB     r2,[r4,#0x14]
;;;512      SD_csd->MaxRdCurrentVDDMax = (CSD_Tab[8] & 0x07);
0000e2  f0000007          AND      r0,r0,#7
0000e6  7560              STRB     r0,[r4,#0x15]
;;;513    
;;;514      /*!< Byte 9 */
;;;515      SD_csd->MaxWrCurrentVDDMin = (CSD_Tab[9] & 0xE0) >> 5;
0000e8  f89d0009          LDRB     r0,[sp,#9]
0000ec  0942              LSRS     r2,r0,#5
0000ee  75a2              STRB     r2,[r4,#0x16]
;;;516      SD_csd->MaxWrCurrentVDDMax = (CSD_Tab[9] & 0x1C) >> 2;
0000f0  f3c00282          UBFX     r2,r0,#2,#3
0000f4  75e2              STRB     r2,[r4,#0x17]
;;;517      SD_csd->DeviceSizeMul = (CSD_Tab[9] & 0x03) << 1;
0000f6  0780              LSLS     r0,r0,#30
0000f8  0f40              LSRS     r0,r0,#29
0000fa  7620              STRB     r0,[r4,#0x18]
;;;518      /*!< Byte 10 */
;;;519      SD_csd->DeviceSizeMul |= (CSD_Tab[10] & 0x80) >> 7;
0000fc  7e22              LDRB     r2,[r4,#0x18]
0000fe  f89d000a          LDRB     r0,[sp,#0xa]
000102  ea4212d0          ORR      r2,r2,r0,LSR #7
000106  7622              STRB     r2,[r4,#0x18]
;;;520        
;;;521      SD_csd->EraseGrSize = (CSD_Tab[10] & 0x40) >> 6;
000108  f3c01280          UBFX     r2,r0,#6,#1
00010c  7662              STRB     r2,[r4,#0x19]
;;;522      SD_csd->EraseGrMul = (CSD_Tab[10] & 0x3F) << 1;
00010e  0680              LSLS     r0,r0,#26
000110  0e40              LSRS     r0,r0,#25
000112  76a0              STRB     r0,[r4,#0x1a]
;;;523    
;;;524      /*!< Byte 11 */
;;;525      SD_csd->EraseGrMul |= (CSD_Tab[11] & 0x80) >> 7;
000114  7ea2              LDRB     r2,[r4,#0x1a]
000116  f89d000b          LDRB     r0,[sp,#0xb]
00011a  ea4212d0          ORR      r2,r2,r0,LSR #7
00011e  76a2              STRB     r2,[r4,#0x1a]
;;;526      SD_csd->WrProtectGrSize = (CSD_Tab[11] & 0x7F);
000120  f000007f          AND      r0,r0,#0x7f
000124  76e0              STRB     r0,[r4,#0x1b]
;;;527    
;;;528      /*!< Byte 12 */
;;;529      SD_csd->WrProtectGrEnable = (CSD_Tab[12] & 0x80) >> 7;
000126  f89d000c          LDRB     r0,[sp,#0xc]
00012a  09c2              LSRS     r2,r0,#7
00012c  7722              STRB     r2,[r4,#0x1c]
;;;530      SD_csd->ManDeflECC = (CSD_Tab[12] & 0x60) >> 5;
00012e  f3c01241          UBFX     r2,r0,#5,#2
000132  7762              STRB     r2,[r4,#0x1d]
;;;531      SD_csd->WrSpeedFact = (CSD_Tab[12] & 0x1C) >> 2;
000134  f3c00282          UBFX     r2,r0,#2,#3
000138  77a2              STRB     r2,[r4,#0x1e]
;;;532      SD_csd->MaxWrBlockLen = (CSD_Tab[12] & 0x03) << 2;
00013a  0780              LSLS     r0,r0,#30
00013c  0f00              LSRS     r0,r0,#28
00013e  77e0              STRB     r0,[r4,#0x1f]
;;;533    
;;;534      /*!< Byte 13 */
;;;535      SD_csd->MaxWrBlockLen |= (CSD_Tab[13] & 0xC0) >> 6;
000140  7fe2              LDRB     r2,[r4,#0x1f]
000142  f89d000d          LDRB     r0,[sp,#0xd]
000146  ea421290          ORR      r2,r2,r0,LSR #6
00014a  77e2              STRB     r2,[r4,#0x1f]
;;;536      SD_csd->WriteBlockPaPartial = (CSD_Tab[13] & 0x20) >> 5;
00014c  f3c01240          UBFX     r2,r0,#5,#1
000150  f8842020          STRB     r2,[r4,#0x20]
;;;537      SD_csd->Reserved3 = 0;
000154  f8841021          STRB     r1,[r4,#0x21]
;;;538      SD_csd->ContentProtectAppli = (CSD_Tab[13] & 0x01);
000158  f0000001          AND      r0,r0,#1
00015c  f8840022          STRB     r0,[r4,#0x22]
;;;539    
;;;540      /*!< Byte 14 */
;;;541      SD_csd->FileFormatGrouop = (CSD_Tab[14] & 0x80) >> 7;
000160  f89d000e          LDRB     r0,[sp,#0xe]
000164  09c1              LSRS     r1,r0,#7
000166  f8841023          STRB     r1,[r4,#0x23]
;;;542      SD_csd->CopyFlag = (CSD_Tab[14] & 0x40) >> 6;
00016a  f3c01180          UBFX     r1,r0,#6,#1
00016e  f8841024          STRB     r1,[r4,#0x24]
;;;543      SD_csd->PermWrProtect = (CSD_Tab[14] & 0x20) >> 5;
000172  f3c01140          UBFX     r1,r0,#5,#1
000176  f8841025          STRB     r1,[r4,#0x25]
;;;544      SD_csd->TempWrProtect = (CSD_Tab[14] & 0x10) >> 4;
00017a  f3c01100          UBFX     r1,r0,#4,#1
00017e  f8841026          STRB     r1,[r4,#0x26]
;;;545      SD_csd->FileFormat = (CSD_Tab[14] & 0x0C) >> 2;
000182  f3c00181          UBFX     r1,r0,#2,#2
000186  f8841027          STRB     r1,[r4,#0x27]
;;;546      SD_csd->ECC = (CSD_Tab[14] & 0x03);
00018a  f0000003          AND      r0,r0,#3
00018e  f8840028          STRB     r0,[r4,#0x28]
;;;547    
;;;548      /*!< Byte 15 */
;;;549      SD_csd->CSD_CRC = (CSD_Tab[15] & 0xFE) >> 1;
000192  f89d000f          LDRB     r0,[sp,#0xf]
000196  0840              LSRS     r0,r0,#1
000198  f8840029          STRB     r0,[r4,#0x29]
;;;550      SD_csd->Reserved4 = 1;
00019c  2001              MOVS     r0,#1
00019e  f884002a          STRB     r0,[r4,#0x2a]
;;;551    
;;;552      /*!< Return the reponse */
;;;553      return rvalue;
;;;554    }
0001a2  b004              ADD      sp,sp,#0x10
0001a4  4628              MOV      r0,r5                 ;553
0001a6  e8bd81f0          POP      {r4-r8,pc}
;;;555    
                          ENDP

0001aa  0000              DCW      0x0000
                  |L4.428|
                          DCD      0x40011000

                          AREA ||i.SD_GetCardInfo||, CODE, READONLY, ALIGN=1

                  SD_GetCardInfo PROC
;;;182      */
;;;183    SD_Error SD_GetCardInfo(SD_CardInfo *cardinfo)
000000  b510              PUSH     {r4,lr}
;;;184    {
000002  4604              MOV      r4,r0
;;;185      SD_Error status = SD_RESPONSE_FAILURE;
;;;186    
;;;187      status = SD_GetCSDRegister(&(cardinfo->SD_csd));
000004  f7fffffe          BL       SD_GetCSDRegister
;;;188      status = SD_GetCIDRegister(&(cardinfo->SD_cid));
000008  f104002c          ADD      r0,r4,#0x2c
00000c  f7fffffe          BL       SD_GetCIDRegister
000010  4602              MOV      r2,r0
;;;189      cardinfo->CardCapacity = (cardinfo->SD_csd.DeviceSize + 1) ;
000012  6920              LDR      r0,[r4,#0x10]
;;;190      cardinfo->CardCapacity *= (1 << (cardinfo->SD_csd.DeviceSizeMul + 2));
000014  7e21              LDRB     r1,[r4,#0x18]
000016  1c40              ADDS     r0,r0,#1
000018  1c89              ADDS     r1,r1,#2
;;;191      cardinfo->CardBlockSize = 1 << (cardinfo->SD_csd.RdBlockLen);
00001a  7a23              LDRB     r3,[r4,#8]
00001c  4088              LSLS     r0,r0,r1              ;190
00001e  2101              MOVS     r1,#1
000020  4099              LSLS     r1,r1,r3
;;;192      cardinfo->CardCapacity *= cardinfo->CardBlockSize;
000022  4348              MULS     r0,r1,r0
;;;193    
;;;194      /*!< Returns the reponse */
;;;195      return status;
000024  e9c40111          STRD     r0,r1,[r4,#0x44]
000028  4610              MOV      r0,r2
;;;196    }
00002a  bd10              POP      {r4,pc}
;;;197    
                          ENDP


                          AREA ||i.SD_GetDataResponse||, CODE, READONLY, ALIGN=1

                  SD_GetDataResponse PROC
;;;692      */
;;;693    uint8_t SD_GetDataResponse(void)
000000  b570              PUSH     {r4-r6,lr}
;;;694    {
;;;695      uint32_t i = 0;
000002  2400              MOVS     r4,#0
                  |L6.4|
;;;696      uint8_t response, rvalue;
;;;697    
;;;698      while (i <= 64)
;;;699      {
;;;700        /*!< Read resonse */
;;;701        response = SD_ReadByte();
000004  f7fffffe          BL       SD_ReadByte
;;;702        /*!< Mask unused bits */
;;;703        response &= 0x1F;
000008  f000051f          AND      r5,r0,#0x1f
;;;704        switch (response)
00000c  2d05              CMP      r5,#5
00000e  d006              BEQ      |L6.30|
000010  2d0b              CMP      r5,#0xb
000012  d00a              BEQ      |L6.42|
000014  2d0d              CMP      r5,#0xd
000016  d00a              BEQ      |L6.46|
000018  1c64              ADDS     r4,r4,#1
00001a  2c40              CMP      r4,#0x40              ;698
;;;705        {
;;;706          case SD_DATA_OK:
;;;707          {
;;;708            rvalue = SD_DATA_OK;
;;;709            break;
;;;710          }
;;;711          case SD_DATA_CRC_ERROR:
;;;712            return SD_DATA_CRC_ERROR;
;;;713          case SD_DATA_WRITE_ERROR:
;;;714            return SD_DATA_WRITE_ERROR;
;;;715          default:
;;;716          {
;;;717            rvalue = SD_DATA_OTHER_ERROR;
;;;718            break;
00001c  d9f2              BLS      |L6.4|
                  |L6.30|
;;;719          }
;;;720        }
;;;721        /*!< Exit loop in case of data ok */
;;;722        if (rvalue == SD_DATA_OK)
;;;723          break;
;;;724        /*!< Increment loop counter */
;;;725        i++;
;;;726      }
;;;727    
;;;728      /*!< Wait null data */
;;;729      while (SD_ReadByte() == 0);
00001e  f7fffffe          BL       SD_ReadByte
000022  2800              CMP      r0,#0
000024  d0fb              BEQ      |L6.30|
;;;730    
;;;731      /*!< Return response */
;;;732      return response;
000026  4628              MOV      r0,r5
;;;733    }
000028  bd70              POP      {r4-r6,pc}
                  |L6.42|
00002a  200b              MOVS     r0,#0xb               ;712
00002c  bd70              POP      {r4-r6,pc}
                  |L6.46|
00002e  200d              MOVS     r0,#0xd               ;714
000030  bd70              POP      {r4-r6,pc}
;;;734    
                          ENDP


                          AREA ||i.SD_GetResponse||, CODE, READONLY, ALIGN=1

                  SD_GetResponse PROC
;;;741      */
;;;742    SD_Error SD_GetResponse(uint8_t Response)
000000  b570              PUSH     {r4-r6,lr}
;;;743    {
000002  4605              MOV      r5,r0
;;;744      uint32_t Count = 0xFFF;
000004  f64074ff          MOV      r4,#0xfff
000008  e000              B        |L7.12|
                  |L7.10|
00000a  1e64              SUBS     r4,r4,#1              ;743
                  |L7.12|
;;;745    
;;;746      /*!< Check if response is got or a timeout is happen */
;;;747      while ((SD_ReadByte() != Response) && Count)
00000c  f7fffffe          BL       SD_ReadByte
000010  42a8              CMP      r0,r5
000012  d002              BEQ      |L7.26|
000014  2c00              CMP      r4,#0
000016  d1f8              BNE      |L7.10|
000018  e002              B        |L7.32|
                  |L7.26|
;;;748      {
;;;749        Count--;
;;;750      }
;;;751      if (Count == 0)
00001a  b10c              CBZ      r4,|L7.32|
;;;752      {
;;;753        /*!< After time out */
;;;754        return SD_RESPONSE_FAILURE;
;;;755      }
;;;756      else
;;;757      {
;;;758        /*!< Right response got */
;;;759        return SD_RESPONSE_NO_ERROR;
00001c  2000              MOVS     r0,#0
;;;760      }
;;;761    }
00001e  bd70              POP      {r4-r6,pc}
                  |L7.32|
000020  20ff              MOVS     r0,#0xff              ;754
000022  bd70              POP      {r4-r6,pc}
;;;762    
                          ENDP


                          AREA ||i.SD_GetStatus||, CODE, READONLY, ALIGN=2

                  SD_GetStatus PROC
;;;767      */
;;;768    uint16_t SD_GetStatus(void)
000000  b570              PUSH     {r4-r6,lr}
;;;769    {
;;;770      uint16_t Status = 0;
;;;771    
;;;772      /*!< SD chip select low */
;;;773      SD_CS_LOW();
000002  4e0e              LDR      r6,|L8.60|
000004  f44f5580          MOV      r5,#0x1000
000008  4629              MOV      r1,r5
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       GPIO_ResetBits
;;;774    
;;;775      /*!< Send CMD13 (SD_SEND_STATUS) to get SD status */
;;;776      SD_SendCmd(SD_CMD_SEND_STATUS, 0, 0xFF);
000010  22ff              MOVS     r2,#0xff
000012  2100              MOVS     r1,#0
000014  200d              MOVS     r0,#0xd
000016  f7fffffe          BL       SD_SendCmd
;;;777    
;;;778      Status = SD_ReadByte();
00001a  f7fffffe          BL       SD_ReadByte
00001e  4604              MOV      r4,r0
;;;779      Status |= (uint16_t)(SD_ReadByte() << 8);
000020  f7fffffe          BL       SD_ReadByte
000024  ea442400          ORR      r4,r4,r0,LSL #8
;;;780    
;;;781      /*!< SD chip select high */
;;;782      SD_CS_HIGH();
000028  4629              MOV      r1,r5
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       GPIO_SetBits
;;;783    
;;;784      /*!< Send dummy byte 0xFF */
;;;785      SD_WriteByte(SD_DUMMY_BYTE);
000030  20ff              MOVS     r0,#0xff
000032  f7fffffe          BL       SD_WriteByte
;;;786    
;;;787      return Status;
000036  4620              MOV      r0,r4
;;;788    }
000038  bd70              POP      {r4-r6,pc}
;;;789    
                          ENDP

00003a  0000              DCW      0x0000
                  |L8.60|
                          DCD      0x40011000

                          AREA ||i.SD_GoIdleState||, CODE, READONLY, ALIGN=2

                  SD_GoIdleState PROC
;;;796      */
;;;797    SD_Error SD_GoIdleState(void)
000000  b570              PUSH     {r4-r6,lr}
;;;798    {
;;;799      /*!< SD chip select low */
;;;800      SD_CS_LOW();
000002  4c18              LDR      r4,|L9.100|
000004  f44f5580          MOV      r5,#0x1000
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       GPIO_ResetBits
;;;801      
;;;802      /*!< Send CMD0 (SD_CMD_GO_IDLE_STATE) to put SD in SPI mode */
;;;803      SD_SendCmd(SD_CMD_GO_IDLE_STATE, 0, 0x95);
000010  2100              MOVS     r1,#0
000012  2295              MOVS     r2,#0x95
000014  4608              MOV      r0,r1
000016  f7fffffe          BL       SD_SendCmd
;;;804      
;;;805      /*!< Wait for In Idle State Response (R1 Format) equal to 0x01 */
;;;806      if (SD_GetResponse(SD_IN_IDLE_STATE))
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       SD_GetResponse
000020  b108              CBZ      r0,|L9.38|
;;;807      {
;;;808        /*!< No Idle State Response: return response failue */
;;;809        return SD_RESPONSE_FAILURE;
000022  20ff              MOVS     r0,#0xff
;;;810      }
;;;811      /*----------Activates the card initialization process-----------*/
;;;812      do
;;;813      {
;;;814        /*!< SD chip select high */
;;;815        SD_CS_HIGH();
;;;816        
;;;817        /*!< Send Dummy byte 0xFF */
;;;818        SD_WriteByte(SD_DUMMY_BYTE);
;;;819        
;;;820        /*!< SD chip select low */
;;;821        SD_CS_LOW();
;;;822        
;;;823        /*!< Send CMD1 (Activates the card process) until response equal to 0x0 */
;;;824        SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
;;;825        /*!< Wait for no error Response (R1 Format) equal to 0x00 */
;;;826      }
;;;827      while (SD_GetResponse(SD_RESPONSE_NO_ERROR));
;;;828      
;;;829      /*!< SD chip select high */
;;;830      SD_CS_HIGH();
;;;831      
;;;832      /*!< Send dummy byte 0xFF */
;;;833      SD_WriteByte(SD_DUMMY_BYTE);
;;;834      
;;;835      return SD_RESPONSE_NO_ERROR;
;;;836    }
000024  bd70              POP      {r4-r6,pc}
                  |L9.38|
000026  4629              MOV      r1,r5                 ;815
000028  4620              MOV      r0,r4                 ;815
00002a  f7fffffe          BL       GPIO_SetBits
00002e  20ff              MOVS     r0,#0xff              ;818
000030  f7fffffe          BL       SD_WriteByte
000034  4629              MOV      r1,r5                 ;821
000036  4620              MOV      r0,r4                 ;821
000038  f7fffffe          BL       GPIO_ResetBits
00003c  22ff              MOVS     r2,#0xff              ;824
00003e  2100              MOVS     r1,#0                 ;824
000040  2001              MOVS     r0,#1                 ;824
000042  f7fffffe          BL       SD_SendCmd
000046  2000              MOVS     r0,#0                 ;827
000048  f7fffffe          BL       SD_GetResponse
00004c  2800              CMP      r0,#0                 ;827
00004e  d1ea              BNE      |L9.38|
000050  4629              MOV      r1,r5                 ;830
000052  4620              MOV      r0,r4                 ;830
000054  f7fffffe          BL       GPIO_SetBits
000058  20ff              MOVS     r0,#0xff              ;833
00005a  f7fffffe          BL       SD_WriteByte
00005e  2000              MOVS     r0,#0                 ;835
000060  bd70              POP      {r4-r6,pc}
;;;837    
                          ENDP

000062  0000              DCW      0x0000
                  |L9.100|
                          DCD      0x40011000

                          AREA ||i.SD_Init||, CODE, READONLY, ALIGN=2

                  SD_Init PROC
;;;135      */
;;;136    SD_Error SD_Init(void)
000000  b510              PUSH     {r4,lr}
;;;137    {
;;;138      uint32_t i = 0;
000002  2400              MOVS     r4,#0
;;;139    
;;;140      /*!< Initialize SD_SPI */
;;;141      SD_LowLevel_Init(); 
000004  f7fffffe          BL       SD_LowLevel_Init
;;;142    
;;;143      /*!< SD chip select high */
;;;144      SD_CS_HIGH();
000008  f44f5180          MOV      r1,#0x1000
00000c  4806              LDR      r0,|L10.40|
00000e  f7fffffe          BL       GPIO_SetBits
                  |L10.18|
;;;145    
;;;146      /*!< Send dummy byte 0xFF, 10 times with CS high */
;;;147      /*!< Rise CS and MOSI for 80 clocks cycles */
;;;148      for (i = 0; i <= 9; i++)
;;;149      {
;;;150        /*!< Send dummy byte 0xFF */
;;;151        SD_WriteByte(SD_DUMMY_BYTE);
000012  20ff              MOVS     r0,#0xff
000014  f7fffffe          BL       SD_WriteByte
000018  1c64              ADDS     r4,r4,#1
00001a  2c09              CMP      r4,#9                 ;148
00001c  d9f9              BLS      |L10.18|
;;;152      }
;;;153      /*------------Put SD in SPI mode--------------*/
;;;154      /*!< SD initialized and set to SPI mode properly */
;;;155      return (SD_GoIdleState());
00001e  e8bd4010          POP      {r4,lr}
000022  f7ffbffe          B.W      SD_GoIdleState
;;;156    }
;;;157    
                          ENDP

000026  0000              DCW      0x0000
                  |L10.40|
                          DCD      0x40011000

                          AREA ||i.SD_ReadBlock||, CODE, READONLY, ALIGN=2

                  SD_ReadBlock PROC
;;;207      */
;;;208    SD_Error SD_ReadBlock(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;209    {
;;;210      uint32_t i = 0;
;;;211      SD_Error rvalue = SD_RESPONSE_FAILURE;
;;;212    
;;;213      /*!< SD chip select low */
;;;214      SD_CS_LOW();
000004  f8dfa060          LDR      r10,|L11.104|
000008  4688              MOV      r8,r1                 ;209
00000a  4605              MOV      r5,r0                 ;209
00000c  f44f5980          MOV      r9,#0x1000
000010  4617              MOV      r7,r2                 ;209
000012  2400              MOVS     r4,#0                 ;210
000014  26ff              MOVS     r6,#0xff              ;211
000016  4649              MOV      r1,r9
000018  4650              MOV      r0,r10
00001a  f7fffffe          BL       GPIO_ResetBits
;;;215      
;;;216      /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
;;;217      SD_SendCmd(SD_CMD_READ_SINGLE_BLOCK, ReadAddr, 0xFF);
00001e  22ff              MOVS     r2,#0xff
000020  4641              MOV      r1,r8
000022  2011              MOVS     r0,#0x11
000024  f7fffffe          BL       SD_SendCmd
;;;218      
;;;219      /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
;;;220      if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
000028  2000              MOVS     r0,#0
00002a  f7fffffe          BL       SD_GetResponse
00002e  b988              CBNZ     r0,|L11.84|
;;;221      {
;;;222        /*!< Now look for the data token to signify the start of the data */
;;;223        if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
000030  20fe              MOVS     r0,#0xfe
000032  f7fffffe          BL       SD_GetResponse
000036  b130              CBZ      r0,|L11.70|
000038  e00c              B        |L11.84|
;;;224        {
;;;225          /*!< Read the SD block data : read NumByteToRead data */
;;;226          for (i = 0; i < BlockSize; i++)
;;;227          {
;;;228            /*!< Save the received data */
;;;229            *pBuffer = SD_ReadByte();
00003a  bf00              NOP      
                  |L11.60|
00003c  f7fffffe          BL       SD_ReadByte
000040  f8050b01          STRB     r0,[r5],#1
000044  1c64              ADDS     r4,r4,#1
                  |L11.70|
000046  42bc              CMP      r4,r7                 ;226
000048  d3f8              BCC      |L11.60|
;;;230           
;;;231            /*!< Point to the next location where the byte read will be saved */
;;;232            pBuffer++;
;;;233          }
;;;234          /*!< Get CRC bytes (not really needed by us, but required by SD) */
;;;235          SD_ReadByte();
00004a  f7fffffe          BL       SD_ReadByte
;;;236          SD_ReadByte();
00004e  f7fffffe          BL       SD_ReadByte
;;;237          /*!< Set response value to success */
;;;238          rvalue = SD_RESPONSE_NO_ERROR;
000052  2600              MOVS     r6,#0
                  |L11.84|
;;;239        }
;;;240      }
;;;241      /*!< SD chip select high */
;;;242      SD_CS_HIGH();
000054  4649              MOV      r1,r9
000056  4650              MOV      r0,r10
000058  f7fffffe          BL       GPIO_SetBits
;;;243      
;;;244      /*!< Send dummy byte: 8 Clock pulses of delay */
;;;245      SD_WriteByte(SD_DUMMY_BYTE);
00005c  20ff              MOVS     r0,#0xff
00005e  f7fffffe          BL       SD_WriteByte
;;;246      
;;;247      /*!< Returns the reponse */
;;;248      return rvalue;
000062  4630              MOV      r0,r6
;;;249    }
000064  e8bd87f0          POP      {r4-r10,pc}
;;;250    
                          ENDP

                  |L11.104|
                          DCD      0x40011000

                          AREA ||i.SD_ReadByte||, CODE, READONLY, ALIGN=2

                  SD_ReadByte PROC
;;;866      */
;;;867    uint8_t SD_ReadByte(void)
000000  b510              PUSH     {r4,lr}
;;;868    {
;;;869      uint8_t Data = 0;
;;;870      
;;;871      /*!< Wait until the transmit buffer is empty */
;;;872      while (SPI_I2S_GetFlagStatus(SD_SPI, SPI_I2S_FLAG_TXE) == RESET)
000002  4c0b              LDR      r4,|L12.48|
                  |L12.4|
000004  2102              MOVS     r1,#2
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000c  2800              CMP      r0,#0
00000e  d0f9              BEQ      |L12.4|
;;;873      {
;;;874      }
;;;875      /*!< Send the byte */
;;;876      SPI_I2S_SendData(SD_SPI, SD_DUMMY_BYTE);
000010  21ff              MOVS     r1,#0xff
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       SPI_I2S_SendData
                  |L12.24|
;;;877    
;;;878      /*!< Wait until a data is received */
;;;879      while (SPI_I2S_GetFlagStatus(SD_SPI, SPI_I2S_FLAG_RXNE) == RESET)
000018  2101              MOVS     r1,#1
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       SPI_I2S_GetFlagStatus
000020  2800              CMP      r0,#0
000022  d0f9              BEQ      |L12.24|
;;;880      {
;;;881      }
;;;882      /*!< Get the received data */
;;;883      Data = (uint8_t)SPI_I2S_ReceiveData(SD_SPI);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       SPI_I2S_ReceiveData
00002a  b2c0              UXTB     r0,r0
;;;884    
;;;885      /*!< Return the shifted data */
;;;886      return Data;
;;;887    }
00002c  bd10              POP      {r4,pc}
;;;888    
                          ENDP

00002e  0000              DCW      0x0000
                  |L12.48|
                          DCD      0x40013000

                          AREA ||i.SD_ReadMultiBlocks||, CODE, READONLY, ALIGN=2

                  SD_ReadMultiBlocks PROC
;;;261      */
;;;262    SD_Error SD_ReadMultiBlocks(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;263    {
;;;264      uint32_t i = 0, Offset = 0;
;;;265      SD_Error rvalue = SD_RESPONSE_FAILURE;
;;;266      
;;;267      /*!< SD chip select low */
;;;268      SD_CS_LOW();
000004  f8dfb07c          LDR      r11,|L13.132|
000008  4689              MOV      r9,r1                 ;263
00000a  4605              MOV      r5,r0                 ;263
00000c  f44f5a80          MOV      r10,#0x1000
000010  461e              MOV      r6,r3                 ;263
000012  4617              MOV      r7,r2                 ;263
000014  f04f0800          MOV      r8,#0                 ;264
000018  24ff              MOVS     r4,#0xff              ;265
00001a  4651              MOV      r1,r10
00001c  4658              MOV      r0,r11
00001e  f7fffffe          BL       GPIO_ResetBits
;;;269      /*!< Data transfer */
;;;270      while (NumberOfBlocks--)
000022  e011              B        |L13.72|
                  |L13.36|
;;;271      {
;;;272        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
;;;273        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK, ReadAddr + Offset, 0xFF);
000024  eb090108          ADD      r1,r9,r8
000028  22ff              MOVS     r2,#0xff
00002a  2011              MOVS     r0,#0x11
00002c  f7fffffe          BL       SD_SendCmd
;;;274        /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
;;;275        if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
000030  2000              MOVS     r0,#0
000032  f7fffffe          BL       SD_GetResponse
000036  b110              CBZ      r0,|L13.62|
;;;276        {
;;;277          return  SD_RESPONSE_FAILURE;
000038  20ff              MOVS     r0,#0xff
                  |L13.58|
;;;278        }
;;;279        /*!< Now look for the data token to signify the start of the data */
;;;280        if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
;;;281        {
;;;282          /*!< Read the SD block data : read NumByteToRead data */
;;;283          for (i = 0; i < BlockSize; i++)
;;;284          {
;;;285            /*!< Read the pointed data */
;;;286            *pBuffer = SD_ReadByte();
;;;287            /*!< Point to the next location where the byte read will be saved */
;;;288            pBuffer++;
;;;289          }
;;;290          /*!< Set next read address*/
;;;291          Offset += 512;
;;;292          /*!< get CRC bytes (not really needed by us, but required by SD) */
;;;293          SD_ReadByte();
;;;294          SD_ReadByte();
;;;295          /*!< Set response value to success */
;;;296          rvalue = SD_RESPONSE_NO_ERROR;
;;;297        }
;;;298        else
;;;299        {
;;;300          /*!< Set response value to failure */
;;;301          rvalue = SD_RESPONSE_FAILURE;
;;;302        }
;;;303      }
;;;304      /*!< SD chip select high */
;;;305      SD_CS_HIGH();
;;;306      /*!< Send dummy byte: 8 Clock pulses of delay */
;;;307      SD_WriteByte(SD_DUMMY_BYTE);
;;;308      /*!< Returns the reponse */
;;;309      return rvalue;
;;;310    }
00003a  e8bd9ff0          POP      {r4-r12,pc}
                  |L13.62|
00003e  20fe              MOVS     r0,#0xfe              ;280
000040  f7fffffe          BL       SD_GetResponse
000044  b158              CBZ      r0,|L13.94|
000046  24ff              MOVS     r4,#0xff              ;301
                  |L13.72|
000048  1e76              SUBS     r6,r6,#1              ;301
00004a  d2eb              BCS      |L13.36|
00004c  4651              MOV      r1,r10                ;305
00004e  4658              MOV      r0,r11                ;305
000050  f7fffffe          BL       GPIO_SetBits
000054  20ff              MOVS     r0,#0xff              ;307
000056  f7fffffe          BL       SD_WriteByte
00005a  4620              MOV      r0,r4                 ;309
00005c  e7ed              B        |L13.58|
                  |L13.94|
00005e  2400              MOVS     r4,#0                 ;283
000060  e005              B        |L13.110|
000062  bf00              NOP                            ;286
                  |L13.100|
000064  f7fffffe          BL       SD_ReadByte
000068  f8050b01          STRB     r0,[r5],#1            ;286
00006c  1c64              ADDS     r4,r4,#1              ;286
                  |L13.110|
00006e  42bc              CMP      r4,r7                 ;283
000070  d3f8              BCC      |L13.100|
000072  f5087800          ADD      r8,r8,#0x200          ;291
000076  f7fffffe          BL       SD_ReadByte
00007a  f7fffffe          BL       SD_ReadByte
00007e  2400              MOVS     r4,#0                 ;296
000080  e7e2              B        |L13.72|
;;;311    
                          ENDP

000082  0000              DCW      0x0000
                  |L13.132|
                          DCD      0x40011000

                          AREA ||i.SD_SendCmd||, CODE, READONLY, ALIGN=1

                  SD_SendCmd PROC
;;;659      */
;;;660    void SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
000000  b57c              PUSH     {r2-r6,lr}
;;;661    {
;;;662      uint32_t i = 0x00;
;;;663      
;;;664      uint8_t Frame[6];
;;;665      
;;;666      Frame[0] = (Cmd | 0x40); /*!< Construct byte 1 */
000002  f0400040          ORR      r0,r0,#0x40
000006  f88d0000          STRB     r0,[sp,#0]
;;;667      
;;;668      Frame[1] = (uint8_t)(Arg >> 24); /*!< Construct byte 2 */
00000a  0e08              LSRS     r0,r1,#24
00000c  f88d0001          STRB     r0,[sp,#1]
;;;669      
;;;670      Frame[2] = (uint8_t)(Arg >> 16); /*!< Construct byte 3 */
000010  0c08              LSRS     r0,r1,#16
000012  2400              MOVS     r4,#0                 ;662
000014  f88d0002          STRB     r0,[sp,#2]
;;;671      
;;;672      Frame[3] = (uint8_t)(Arg >> 8); /*!< Construct byte 4 */
000018  0a08              LSRS     r0,r1,#8
;;;673      
;;;674      Frame[4] = (uint8_t)(Arg); /*!< Construct byte 5 */
00001a  f88d1004          STRB     r1,[sp,#4]
00001e  f88d0003          STRB     r0,[sp,#3]            ;672
;;;675      
;;;676      Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
000022  f88d2005          STRB     r2,[sp,#5]
000026  466d              MOV      r5,sp                 ;664
                  |L14.40|
;;;677      
;;;678      for (i = 0; i < 6; i++)
;;;679      {
;;;680        SD_WriteByte(Frame[i]); /*!< Send the Cmd bytes */
000028  5d28              LDRB     r0,[r5,r4]
00002a  f7fffffe          BL       SD_WriteByte
00002e  1c64              ADDS     r4,r4,#1
000030  2c06              CMP      r4,#6                 ;678
000032  d3f9              BCC      |L14.40|
;;;681      }
;;;682    }
000034  bd7c              POP      {r2-r6,pc}
;;;683    
                          ENDP


                          AREA ||i.SD_WriteBlock||, CODE, READONLY, ALIGN=2

                  SD_WriteBlock PROC
;;;321      */
;;;322    SD_Error SD_WriteBlock(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;323    {
;;;324      uint32_t i = 0;
;;;325      SD_Error rvalue = SD_RESPONSE_FAILURE;
;;;326    
;;;327      /*!< SD chip select low */
;;;328      SD_CS_LOW();
000004  f8dfa06c          LDR      r10,|L15.116|
000008  4688              MOV      r8,r1                 ;323
00000a  4605              MOV      r5,r0                 ;323
00000c  f44f5980          MOV      r9,#0x1000
000010  4617              MOV      r7,r2                 ;323
000012  2400              MOVS     r4,#0                 ;324
000014  26ff              MOVS     r6,#0xff              ;325
000016  4649              MOV      r1,r9
000018  4650              MOV      r0,r10
00001a  f7fffffe          BL       GPIO_ResetBits
;;;329    
;;;330      /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write multiple block */
;;;331      SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr, 0xFF);
00001e  22ff              MOVS     r2,#0xff
000020  4641              MOV      r1,r8
000022  2018              MOVS     r0,#0x18
000024  f7fffffe          BL       SD_SendCmd
;;;332      
;;;333      /*!< Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
;;;334      if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
000028  2000              MOVS     r0,#0
00002a  f7fffffe          BL       SD_GetResponse
00002e  b9b0              CBNZ     r0,|L15.94|
;;;335      {
;;;336        /*!< Send a dummy byte */
;;;337        SD_WriteByte(SD_DUMMY_BYTE);
000030  20ff              MOVS     r0,#0xff
000032  f7fffffe          BL       SD_WriteByte
;;;338    
;;;339        /*!< Send the data token to signify the start of the data */
;;;340        SD_WriteByte(0xFE);
000036  20fe              MOVS     r0,#0xfe
000038  f7fffffe          BL       SD_WriteByte
;;;341    
;;;342        /*!< Write the block data to SD : write count data by block */
;;;343        for (i = 0; i < BlockSize; i++)
00003c  e004              B        |L15.72|
                  |L15.62|
;;;344        {
;;;345          /*!< Send the pointed byte */
;;;346          SD_WriteByte(*pBuffer);
00003e  7828              LDRB     r0,[r5,#0]
000040  f7fffffe          BL       SD_WriteByte
000044  1c64              ADDS     r4,r4,#1
000046  1c6d              ADDS     r5,r5,#1
                  |L15.72|
000048  42bc              CMP      r4,r7                 ;343
00004a  d3f8              BCC      |L15.62|
;;;347          /*!< Point to the next location where the byte read will be saved */
;;;348          pBuffer++;
;;;349        }
;;;350        /*!< Put CRC bytes (not really needed by us, but required by SD) */
;;;351        SD_ReadByte();
00004c  f7fffffe          BL       SD_ReadByte
;;;352        SD_ReadByte();
000050  f7fffffe          BL       SD_ReadByte
;;;353    
;;;354        /*!< Read data response */
;;;355        if (SD_GetDataResponse() == SD_DATA_OK)
000054  f7fffffe          BL       SD_GetDataResponse
000058  2805              CMP      r0,#5
00005a  d100              BNE      |L15.94|
;;;356        {
;;;357          rvalue = SD_RESPONSE_NO_ERROR;
00005c  2600              MOVS     r6,#0
                  |L15.94|
;;;358        }
;;;359      }
;;;360      /*!< SD chip select high */
;;;361      SD_CS_HIGH();
00005e  4649              MOV      r1,r9
000060  4650              MOV      r0,r10
000062  f7fffffe          BL       GPIO_SetBits
;;;362      /*!< Send dummy byte: 8 Clock pulses of delay */
;;;363      SD_WriteByte(SD_DUMMY_BYTE);
000066  20ff              MOVS     r0,#0xff
000068  f7fffffe          BL       SD_WriteByte
;;;364    
;;;365      /*!< Returns the reponse */
;;;366      return rvalue;
00006c  4630              MOV      r0,r6
;;;367    }
00006e  e8bd87f0          POP      {r4-r10,pc}
;;;368    
                          ENDP

000072  0000              DCW      0x0000
                  |L15.116|
                          DCD      0x40011000

                          AREA ||i.SD_WriteByte||, CODE, READONLY, ALIGN=2

                  SD_WriteByte PROC
;;;842      */
;;;843    uint8_t SD_WriteByte(uint8_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;844    {
;;;845      /*!< Wait until the transmit buffer is empty */
;;;846      while(SPI_I2S_GetFlagStatus(SD_SPI, SPI_I2S_FLAG_TXE) == RESET)
000002  4c0b              LDR      r4,|L16.48|
000004  4605              MOV      r5,r0                 ;844
                  |L16.6|
000006  2102              MOVS     r1,#2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L16.6|
;;;847      {
;;;848      }
;;;849      
;;;850      /*!< Send the byte */
;;;851      SPI_I2S_SendData(SD_SPI, Data);
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       SPI_I2S_SendData
                  |L16.26|
;;;852      
;;;853      /*!< Wait to receive a byte*/
;;;854      while(SPI_I2S_GetFlagStatus(SD_SPI, SPI_I2S_FLAG_RXNE) == RESET)
00001a  2101              MOVS     r1,#1
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SPI_I2S_GetFlagStatus
000022  2800              CMP      r0,#0
000024  d0f9              BEQ      |L16.26|
;;;855      {
;;;856      }
;;;857      
;;;858      /*!< Return the byte read from the SPI bus */ 
;;;859      return (uint8_t)SPI_I2S_ReceiveData(SD_SPI);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       SPI_I2S_ReceiveData
00002c  b2c0              UXTB     r0,r0
;;;860    }
00002e  bd70              POP      {r4-r6,pc}
;;;861    
                          ENDP

                  |L16.48|
                          DCD      0x40013000

                          AREA ||i.SD_WriteMultiBlocks||, CODE, READONLY, ALIGN=2

                  SD_WriteMultiBlocks PROC
;;;379      */
;;;380    SD_Error SD_WriteMultiBlocks(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;381    {
;;;382      uint32_t i = 0, Offset = 0;
;;;383      SD_Error rvalue = SD_RESPONSE_FAILURE;
;;;384    
;;;385      /*!< SD chip select low */
;;;386      SD_CS_LOW();
000004  f8dfb084          LDR      r11,|L17.140|
000008  4689              MOV      r9,r1                 ;381
00000a  4605              MOV      r5,r0                 ;381
00000c  f44f5a80          MOV      r10,#0x1000
000010  461e              MOV      r6,r3                 ;381
000012  4617              MOV      r7,r2                 ;381
000014  f04f0800          MOV      r8,#0                 ;382
000018  24ff              MOVS     r4,#0xff              ;383
00001a  4651              MOV      r1,r10
00001c  4658              MOV      r0,r11
00001e  f7fffffe          BL       GPIO_ResetBits
;;;387      /*!< Data transfer */
;;;388      while (NumberOfBlocks--)
000022  e025              B        |L17.112|
                  |L17.36|
;;;389      {
;;;390        /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write blocks */
;;;391        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr + Offset, 0xFF);
000024  eb090108          ADD      r1,r9,r8
000028  22ff              MOVS     r2,#0xff
00002a  2018              MOVS     r0,#0x18
00002c  f7fffffe          BL       SD_SendCmd
;;;392        /*!< Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
;;;393        if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
000030  2000              MOVS     r0,#0
000032  f7fffffe          BL       SD_GetResponse
000036  2800              CMP      r0,#0
;;;394        {
;;;395          return SD_RESPONSE_FAILURE;
;;;396        }
;;;397        /*!< Send dummy byte */
;;;398        SD_WriteByte(SD_DUMMY_BYTE);
000038  f04f00ff          MOV      r0,#0xff
00003c  d122              BNE      |L17.132|
00003e  f7fffffe          BL       SD_WriteByte
;;;399        /*!< Send the data token to signify the start of the data */
;;;400        SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
000042  20fe              MOVS     r0,#0xfe
000044  f7fffffe          BL       SD_WriteByte
;;;401        /*!< Write the block data to SD : write count data by block */
;;;402        for (i = 0; i < BlockSize; i++)
000048  2400              MOVS     r4,#0
00004a  e004              B        |L17.86|
                  |L17.76|
;;;403        {
;;;404          /*!< Send the pointed byte */
;;;405          SD_WriteByte(*pBuffer);
00004c  7828              LDRB     r0,[r5,#0]
00004e  f7fffffe          BL       SD_WriteByte
000052  1c64              ADDS     r4,r4,#1
000054  1c6d              ADDS     r5,r5,#1
                  |L17.86|
000056  42bc              CMP      r4,r7                 ;402
000058  d3f8              BCC      |L17.76|
;;;406          /*!< Point to the next location where the byte read will be saved */
;;;407          pBuffer++;
;;;408        }
;;;409        /*!< Set next write address */
;;;410        Offset += 512;
00005a  f5087800          ADD      r8,r8,#0x200
;;;411        /*!< Put CRC bytes (not really needed by us, but required by SD) */
;;;412        SD_ReadByte();
00005e  f7fffffe          BL       SD_ReadByte
;;;413        SD_ReadByte();
000062  f7fffffe          BL       SD_ReadByte
;;;414        /*!< Read data response */
;;;415        if (SD_GetDataResponse() == SD_DATA_OK)
000066  f7fffffe          BL       SD_GetDataResponse
00006a  2805              CMP      r0,#5
00006c  d00c              BEQ      |L17.136|
;;;416        {
;;;417          /*!< Set response value to success */
;;;418          rvalue = SD_RESPONSE_NO_ERROR;
;;;419        }
;;;420        else
;;;421        {
;;;422          /*!< Set response value to failure */
;;;423          rvalue = SD_RESPONSE_FAILURE;
00006e  24ff              MOVS     r4,#0xff
                  |L17.112|
000070  1e76              SUBS     r6,r6,#1
000072  d2d7              BCS      |L17.36|
;;;424        }
;;;425      }
;;;426      /*!< SD chip select high */
;;;427      SD_CS_HIGH();
000074  4651              MOV      r1,r10
000076  4658              MOV      r0,r11
000078  f7fffffe          BL       GPIO_SetBits
;;;428      /*!< Send dummy byte: 8 Clock pulses of delay */
;;;429      SD_WriteByte(SD_DUMMY_BYTE);
00007c  20ff              MOVS     r0,#0xff
00007e  f7fffffe          BL       SD_WriteByte
;;;430      /*!< Returns the reponse */
;;;431      return rvalue;
000082  4620              MOV      r0,r4
                  |L17.132|
;;;432    }
000084  e8bd9ff0          POP      {r4-r12,pc}
                  |L17.136|
000088  2400              MOVS     r4,#0                 ;418
00008a  e7f1              B        |L17.112|
;;;433    
                          ENDP

                  |L17.140|
                          DCD      0x40011000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Utilities\\STM32_EVAL\\STM3210B_EVAL\\stm3210b_eval_spi_sd.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm3210b_eval_spi_sd_c_57851845____REV16|
#line 129 "D:\\Complier\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\3.20.4\\CMSIS\\Include\\core_cmInstr.h"
|__asm___22_stm3210b_eval_spi_sd_c_57851845____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm3210b_eval_spi_sd_c_57851845____REVSH|
#line 144
|__asm___22_stm3210b_eval_spi_sd_c_57851845____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
